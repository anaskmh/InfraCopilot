"""DevOps AI Copilot CLI - Main application."""

import typer
from pathlib import Path
from typing import Optional

from devops_ai.ui import (
    console,
    print_header,
    print_success,
    print_error,
    print_info,
    print_warning,
    print_section,
    print_example,
    ErrorHandler,
    Spinner,
)
from devops_ai.doctor import DoctorRunner
from devops_ai.healing import HealingRunner, IssueSeverity

app = typer.Typer(
    help="üöÄ DevOps AI Copilot - Production-ready infrastructure automation",
    pretty_exceptions_show_locals=False,
    no_args_is_help=True,
)


@app.command()
def init(
    project_name: str = typer.Argument(..., help="Project name for your DevOps setup"),
    provider: str = typer.Option(
        "aws", "--provider", "-p", help="Cloud provider (aws, gcp, azure)"
    ),
):
    """
    üéØ Initialize a new DevOps project with recommended structure.

    Creates project directories, configuration, and README.

    Examples:
      devops-ai init my-project
      devops-ai init backend-api --provider aws
      devops-ai init k8s-stack --provider gcp
    """
    try:
        print_header(f"Initializing Project: {project_name}", f"Provider: {provider.upper()}")

        with Spinner(message=f"[cyan]Setting up project structure...[/cyan]"):
            from devops_ai.utils import ensure_project_dir, save_config

            project_dir = Path(project_name)
            project_dir.mkdir(exist_ok=True)

            # Create project structure
            for subdir in ["terraform", "k8s", "docker", "github-workflows", "outputs"]:
                ensure_project_dir(project_dir / subdir)

            # Create config file
            config = {
                "project_name": project_name,
                "provider": provider,
                "version": "1.0.0",
            }

            save_config(project_dir / ".devops-ai.json", config)

            # Create README
            readme_content = f"""# {project_name} DevOps

Generated by DevOps AI Copilot

## Project Structure

- `terraform/` - Infrastructure as Code
- `k8s/` - Kubernetes manifests
- `docker/` - Docker configurations
- `github-workflows/` - CI/CD workflows
- `outputs/` - Generated files

## Cloud Provider

Provider: {provider.upper()}

## Getting Started

1. Configure cloud credentials
2. Review generated infrastructure files
3. Deploy using appropriate tools
"""

            with open(project_dir / "README.md", "w") as f:
                f.write(readme_content)

        print_success(f"Project '{project_name}' initialized successfully!")
        print_info(f"Location: {project_dir.absolute()}")
        print_info(f"Provider: {provider.upper()}")

        print_section("Next Steps")
        console.print("  1. [cyan]cd my-project[/cyan]")
        console.print("  2. [cyan]devops-ai generate terraform --desc 'your infrastructure'[/cyan]")
        console.print("  3. Review the generated files")

    except Exception as e:
        ErrorHandler.handle_exception(e, "Failed to initialize project")


@app.command()
def generate(
    resource_type: str = typer.Argument(
        "terraform",
        help="Resource type to generate",
    ),
    description: str = typer.Option(
        None, "--desc", "-d", help="Natural language description of what to generate"
    ),
    project_name: str = typer.Option(
        "my-project", "--project", "-p", help="Project name"
    ),
    output_dir: str = typer.Option(
        "outputs", "--output", "-o", help="Output directory for generated files"
    ),
):
    """
    üîß Generate infrastructure code from natural language.

    Supports: terraform, k8s, docker, github-actions

    Examples:
      devops-ai generate terraform --desc "VPC with public subnets"
      devops-ai generate k8s --desc "deploy microservices with auto-scaling"
      devops-ai generate docker --desc "python fastapi app"
      devops-ai generate github-actions --desc "test and deploy to eks"
    """
    try:
        if not description:
            ErrorHandler.handle("empty_input")
            raise typer.Exit(1)

        print_header(
            f"Generating {resource_type.upper()}",
            f"Description: {description[:60]}...",
        )

        with Spinner(message=f"[cyan]Analyzing requirements...[/cyan]"):
            from devops_ai.utils import parse_natural_language

            parsed = parse_natural_language(description)

        with Spinner(message=f"[cyan]Generating {resource_type} code...[/cyan]"):
            from devops_ai.generators import (
                TerraformGenerator,
                KubernetesGenerator,
                GitHubActionsGenerator,
                DockerfileGenerator,
            )
            from devops_ai.utils import write_file

            output_path = Path(output_dir)
            output_path.mkdir(parents=True, exist_ok=True)

            # Generate based on resource type
            if resource_type.lower() == "terraform":
                generator = TerraformGenerator(project_name)
                content = generator.generate(description)
                output_file = output_path / "main.tf"

            elif resource_type.lower() == "k8s":
                generator = KubernetesGenerator(project_name)
                content = generator.generate(description)
                output_file = output_path / "deployment.yaml"

            elif resource_type.lower() == "docker":
                generator = DockerfileGenerator(project_name)
                if "compose" in description.lower():
                    content = generator.generate_dockercompose(description)
                    output_file = output_path / "docker-compose.yml"
                else:
                    content = generator.generate(description)
                    output_file = output_path / "Dockerfile"

            elif resource_type.lower() == "github-actions":
                generator = GitHubActionsGenerator(project_name)
                content = generator.generate(description)
                output_file = output_path / "ci-cd.yml"

            else:
                ErrorHandler.handle("invalid_resource", resource=resource_type)
                raise typer.Exit(1)

            # Write output
            write_file(output_file, content)

        print_success(f"Generated {resource_type} configuration")
        print_info(f"Output: {output_file}")

        print_section("Preview")
        console.print(content[:400] + "...\n")
        print_info(f"File saved with {len(content)} characters")

    except Exception as e:
        ErrorHandler.handle_exception(e, f"Failed to generate {resource_type}")


@app.command()
def diagnose(
    log_file: str = typer.Option(
        None, "--file", "-f", help="Path to log file to analyze"
    ),
    infrastructure: str = typer.Option(
        None, "--infra", "-i", help="Infrastructure type (k8s, docker)"
    ),
    namespace: str = typer.Option(
        "default", "--namespace", "-n", help="Kubernetes namespace"
    ),
):
    """
    üîç Analyze logs and diagnose infrastructure issues.

    Examples:
      devops-ai diagnose --file app.log
      devops-ai diagnose --infra k8s --namespace production
      devops-ai diagnose --infra docker
    """
    try:
        if log_file:
            print_header("Log Analysis", f"File: {log_file}")

            with Spinner(message="[cyan]Analyzing logs...[/cyan]"):
                from devops_ai.diagnostics import LogAnalyzer
                from devops_ai.utils import read_file

                log_content = read_file(Path(log_file))
                analyzer = LogAnalyzer()
                analysis = analyzer.analyze(log_content)

            # Display results
            print_section("Analysis Results")

            from rich.table import Table

            table = Table(title="Issue Summary")
            table.add_column("Severity", style="cyan")
            table.add_column("Count", style="magenta")
            table.add_row("üî¥ Critical", str(analysis["critical"]))
            table.add_row("üü† High", str(analysis["high"]))
            table.add_row("üü° Medium", str(analysis["medium"]))

            console.print(table)

            # Show fixes
            if analysis["issues"]:
                print_section("Suggested Fixes")
                suggestions = analyzer.suggest_fixes(log_content)
                for suggestion in suggestions[:3]:  # Show top 3
                    console.print(suggestion + "\n")
            else:
                print_success("No issues found!")

        elif infrastructure:
            print_header("Infrastructure Diagnostics", f"Type: {infrastructure.upper()}")

            with Spinner(message="[cyan]Running diagnostics...[/cyan]"):
                from devops_ai.diagnostics import DiagnosticRunner

                runner = DiagnosticRunner()

                if infrastructure.lower() == "k8s":
                    results = runner.diagnose_kubernetes(namespace)
                    print_success(f"Kubernetes Diagnostics (namespace: {namespace})")

                elif infrastructure.lower() == "docker":
                    results = runner.diagnose_docker("container")
                    print_success("Docker Diagnostics")

                else:
                    ErrorHandler.handle("invalid_resource", resource=infrastructure)
                    raise typer.Exit(1)

            # Display results
            for check, result in results.items():
                console.print(f"\n[cyan]‚ñ∂ {check.replace('_', ' ').title()}[/cyan]")
                if isinstance(result, dict):
                    for key, value in result.items():
                        console.print(f"  ‚Ä¢ [yellow]{key}[/yellow]: {value}")

        else:
            print_error("Please provide either --file or --infra option")
            print_info("Examples:")
            console.print("  devops-ai diagnose --file app.log")
            console.print("  devops-ai diagnose --infra k8s")
            raise typer.Exit(1)

    except Exception as e:
        ErrorHandler.handle_exception(e, "Diagnostic failed")


@app.command()
def cost(
    report: bool = typer.Option(False, "--report", "-r", help="Generate full cost report"),
):
    """
    üí∞ Analyze cloud cost optimization opportunities.

    Examples:
      devops-ai cost
      devops-ai cost --report
    """
    from devops_ai.cost import CostOptimizer
    from rich.table import Table

    try:
        print_header("Cost Optimization Analysis")

        with Spinner(message="[cyan]Analyzing cost opportunities...[/cyan]"):
            optimizer = CostOptimizer()
            analysis = optimizer.analyze_infrastructure({})

        if report:
            print_section("Detailed Cost Optimization Report")
            report_content = optimizer.generate_cost_report({})
            console.print(report_content)

        else:
            # Display summary table
            table = Table(title="Cost Optimization Recommendations (Top 5)")
            table.add_column("Priority", style="cyan")
            table.add_column("Title", style="magenta")
            table.add_column("Effort", style="yellow")
            table.add_column("Savings", style="green")

            for rec in analysis["recommendations"][:5]:
                emoji = "üî¥" if rec["priority"] == "High" else "üü°"
                table.add_row(
                    f"{emoji} {rec['priority']}",
                    rec["title"],
                    rec["effort"],
                    rec["estimated_savings"],
                )

            console.print(table)

            print_success(f"Found {analysis['high_priority']} high-priority opportunities")
            print_info("Use --report flag for detailed analysis")

    except Exception as e:
        ErrorHandler.handle_exception(e, "Cost analysis failed")


@app.command()
def diagram(
    diagram_type: str = typer.Argument(
        "microservices",
        help="Diagram type to generate",
    ),
    output_file: str = typer.Option(
        "architecture.md", "--output", "-o", help="Output file path"
    ),
):
    """
    üìä Generate architecture diagrams in Mermaid format.

    Examples:
      devops-ai diagram microservices
      devops-ai diagram k8s --output k8s.md
      devops-ai diagram pipeline --output cicd.md
    """
    from devops_ai.diagram import DiagramGenerator
    from devops_ai.utils import write_file

    try:
        print_header(f"Generating {diagram_type.upper()} Diagram")

        with Spinner(message="[cyan]Creating diagram...[/cyan]"):
            generator = DiagramGenerator()

            # Generate based on diagram type
            if diagram_type.lower() == "pipeline":
                content = generator.generate_deployment_pipeline()
                diagram_name = "CI/CD Deployment Pipeline"

            elif diagram_type.lower() == "k8s":
                content = generator.generate_k8s_deployment()
                diagram_name = "Kubernetes Deployment"

            else:
                content = generator.generate_architecture(diagram_type)
                diagram_name = f"{diagram_type.title()} Architecture"

            # Wrap in Markdown
            markdown_content = f"""# {diagram_name}

Generated by DevOps AI Copilot

## Architecture Diagram

```mermaid
{content}
```

## Components

- **Client Layer**: User interfaces and external clients
- **API Layer**: Gateways and load balancers
- **Service Layer**: Business logic and microservices
- **Data Layer**: Databases and caching
- **Integration**: Message queues and external services

## Deployment Notes

- Ensure all security groups and network policies are configured
- Set up monitoring and logging
- Configure backup and disaster recovery
- Implement cost optimization strategies
"""

            output_path = Path(output_file)
            write_file(output_path, markdown_content)

        print_success(f"Generated {diagram_type} diagram")
        print_info(f"Output: {output_path.absolute()}")
        print_info("View in: GitHub, GitLab, or any Mermaid-compatible viewer")

    except Exception as e:
        ErrorHandler.handle_exception(e, f"Failed to generate {diagram_type} diagram")


@app.command()
def doctor(
    full: bool = typer.Option(
        False, "--full", "-f", help="Show installation guides and recommendations"
    ),
):
    """
    üè• Check system health and installed DevOps tools.

    Validates installation of: Terraform, kubectl, Docker, Git, Python
    and optional tools like AWS CLI, Helm, Kind, etc.

    Examples:
      devops-ai doctor
      devops-ai doctor --full
    """
    print_header("DevOps AI System Health Check")

    results = DoctorRunner.run_diagnostics()

    if full:
        console.print()
        DoctorRunner.print_installation_guide()
        console.print()
        DoctorRunner.print_recommendations()

    # Final verdict
    console.print()
    if results["health"] == "excellent":
        print_success(
            f"System Status: {results['health'].upper()}\n"
            + f"               All required tools installed ({results['required_installed']}/{results['required_total']})"
        )
    elif results["health"] == "fair":
        print_warning(
            f"System Status: {results['health'].upper()}\n"
            + f"               {results['required_total'] - results['required_installed']} tool(s) missing"
        )
    else:
        print_error(
            f"System Status: {results['health'].upper()}\n"
            + f"               {results['required_total'] - results['required_installed']} critical tool(s) missing"
        )


@app.command()
def heal(
    scan_type: Optional[str] = typer.Option(
        "all",
        "--scan-type",
        "-s",
        help="Type to scan: all, k8s, terraform, github, logs",
    ),
    file: Optional[Path] = typer.Option(
        None,
        "--file",
        "-f",
        help="Configuration or log file to scan",
    ),
    namespace: Optional[str] = typer.Option(
        None,
        "--namespace",
        "-n",
        help="Kubernetes namespace to scan",
    ),
    severity: Optional[str] = typer.Option(
        None,
        "--severity",
        help="Filter by severity: critical, warning, info",
    ),
    auto_fix: bool = typer.Option(
        False,
        "--auto-fix",
        "-a",
        help="Automatically generate and show fixes",
    ),
):
    """üè• AI Self-Healing Infrastructure

    Detect infrastructure issues and generate automatic fixes for:
    - Kubernetes misconfigurations
    - Terraform state and provider issues
    - GitHub Actions workflow problems
    - Application log errors

    Examples:
    
    [cyan]Scan Kubernetes manifests:[/cyan]
    $ devops-ai heal --scan-type k8s --file deployment.yaml
    
    [cyan]Scan Terraform configuration:[/cyan]
    $ devops-ai heal --scan-type terraform --file main.tf
    
    [cyan]Analyze application logs:[/cyan]
    $ devops-ai heal --scan-type logs --file app.log
    
    [cyan]Generate automatic fixes:[/cyan]
    $ devops-ai heal --auto-fix --file deployment.yaml
    """
    print_header("üè• AI Self-Healing Infrastructure Scanner")

    runner = HealingRunner()
    handler = ErrorHandler()

    # Read file if provided
    config = {}
    if file and file.exists():
        with Spinner("Reading configuration"):
            content = file.read_text()

        if scan_type == "k8s" or (scan_type == "all" and file.suffix in [".yaml", ".yml"]):
            config["kubernetes"] = content
        elif scan_type == "terraform" or (scan_type == "all" and file.suffix == ".tf"):
            config["terraform"] = content
        elif scan_type == "github" or (scan_type == "all" and ".github" in str(file)):
            config["github_actions"] = content
        elif scan_type == "logs" or (scan_type == "all" and file.suffix == ".log"):
            config["logs"] = content
    else:
        handler.print_error("no_file", file=str(file) if file else "unknown")
        return

    # Run scan
    with Spinner("Scanning for infrastructure issues"):
        if scan_type == "all":
            issues = runner.scan_all(config)
        elif scan_type == "k8s":
            issues = runner.scan_kubernetes(config.get("kubernetes", ""))
        elif scan_type == "terraform":
            issues = runner.scan_terraform(config.get("terraform", ""))
        elif scan_type == "github":
            issues = runner.scan_github_actions(config.get("github_actions", ""))
        elif scan_type == "logs":
            issues = runner.analyze_logs(config.get("logs", ""))
        else:
            issues = []

    # Filter by severity if requested
    if severity:
        sev_enum = IssueSeverity(severity.lower())
        issues = runner.filter_by_severity(issues, sev_enum)

    # Display summary
    summary = runner.get_summary(issues)
    print_section("Scan Results")

    console.print(f"[yellow]Total Issues Found:[/yellow] {summary['total_issues']}")
    console.print(f"  [red]üî¥ Critical:[/red] {summary['critical']}")
    console.print(f"  [yellow]üü° Warnings:[/yellow] {summary['warnings']}")
    console.print(f"  [cyan]üîµ Info:[/cyan] {summary['info']}")

    if summary["by_category"]:
        console.print("\n[cyan]By Category:[/cyan]")
        for category, count in summary["by_category"].items():
            console.print(f"  ‚Ä¢ {category}: {count} issues")

    # Display issues
    if issues:
        print_section("Detected Issues")
        for i, issue in enumerate(issues, 1):
            severity_icon = "üî¥" if issue.severity == IssueSeverity.CRITICAL else \
                           "üü°" if issue.severity == IssueSeverity.WARNING else "üîµ"
            console.print(
                f"\n{i}. {severity_icon} [{issue.severity.value}] {issue.title}"
            )
            console.print(f"   Resource: {issue.resource}")
            console.print(f"   Issue: {issue.description}")
            console.print(f"   Root Cause: {issue.root_cause}")
            console.print(f"   Fix: {issue.suggested_fix}")

        # Generate remediation plans if auto-fix enabled
        if auto_fix:
            print_section("Remediation Plans")
            plans = runner.get_remediation_plans(issues)

            for plan in plans:
                console.print(f"\n[cyan]Issue:[/cyan] {plan.issue.title}")
                console.print(f"[yellow]Risk Level:[/yellow] {plan.risk_level}")
                console.print(f"[yellow]Est. Time:[/yellow] {plan.estimated_time}")
                console.print(f"[yellow]Requires Approval:[/yellow] {'Yes' if plan.requires_approval else 'No'}")

                console.print(f"\n[bold]Remediation Steps:[/bold]")
                for step in plan.steps:
                    console.print(
                        f"\n  [{step.order}] {step.title}"
                    )
                    console.print(f"      {step.description}")
                    if step.command and step.command != "# Verify issue is resolved":
                        console.print(f"      [cyan]Command:[/cyan] {step.command}")
                    if step.config_changes:
                        console.print(f"      [dim]{step.config_changes}[/dim]")

            print_success(f"Generated remediation plans for {len(plans)} issue(s)")
    else:
        print_success("‚úÖ No issues detected!")

    print_example(
        "Next Steps",
        """
# Review the issues and remediation plans above

# Generate fixes with auto-fix flag:
devops-ai heal --auto-fix --file deployment.yaml

# Scan specific resource types:
devops-ai heal --scan-type terraform --file main.tf

# Filter by severity:
devops-ai heal --severity critical --auto-fix --file app.log
        """
    )


if __name__ == "__main__":
    app()
